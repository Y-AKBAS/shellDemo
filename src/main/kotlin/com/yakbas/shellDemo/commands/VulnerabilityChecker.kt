package com.yakbas.shellDemo.commands

import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.node.MissingNode
import com.fasterxml.jackson.databind.node.ObjectNode
import org.slf4j.LoggerFactory
import org.springframework.shell.command.annotation.Command
import org.springframework.web.client.RestClient
import org.springframework.web.client.toEntity
import org.springframework.web.util.UriComponentsBuilder
import java.time.LocalDate
import java.util.concurrent.CompletableFuture

data class VulnerabilityData(
    val cveid: String,
    val datePublished: String,
    val baseScore: String,
    val lessThan: String,
    val description: String,
)

data class CveListV5(
    val cvelistv5: List<JsonNode> = listOf(),
)

private const val baseUrl = "https://cve.circl.lu/api"
private const val vulnerabilityUrl = "$baseUrl/vulnerability/search/{vendor}/{product}"
private val vendorSoftwarePairs = setOf(
    "Node.js" to "Node.js",
    "PostgreSQL" to "PostgreSQL",
    "Adobe" to "Acrobat",
    "NGINX" to "NGINX",
    "MongoDB" to "MongoDB",
    "LibreOffice" to "LibreOffice",
    "Teamviewer" to "Teamviewer",
    "PHP" to "PHP",
    "Docker" to "Docker Desktop",
    "OpenSSL" to "OpenSSL",
    "GitLAB" to "GitLAB",
    "python" to "python",
    "zabbix" to "zabbix",
    "grafana" to "grafana",
    "wazuh" to "wazuh",
    "jetbrains" to "IntelliJ IDEA",
)

@Command
class VulnerabilityChecker(
    private val restClient: RestClient,
    private val objectMapper: ObjectMapper
) {

    private val logger = LoggerFactory.getLogger(VulnerabilityChecker::class.java)
    private val prettyWriter = objectMapper.writerWithDefaultPrettyPrinter()

    @Command(command = ["vulnerabilities"])
    fun fetchVulnerabilities(
    ) {
        logger.info("Fetching Vulnerabilities...")
        val allData = vendorSoftwarePairs.map {
            fetchVulnerability(it.first, it.second)
        }.mapNotNull {
            it.join()
        }.flatten()
        logger.info("Writing into excel...")

    }

    private fun fetchVulnerability(vendor: String, product: String) = CompletableFuture.supplyAsync {
        logger.info("Fetching Vulnerability for vendor: $vendor product: $product ...")
        val targetDate = LocalDate.now().minusDays(20).toString()
        val url = UriComponentsBuilder.fromUriString(vulnerabilityUrl).apply {
            uriVariables(mapOf("vendor" to vendor, "product" to product))
            queryParam("since", targetDate)
        }.encode().build().toUriString()

        val response = restClient.get().uri(url).retrieve().toEntity<CveListV5>()
        val data = response.body?.cvelistv5?.mapNotNull {
            val objectNode = it.get(1) as? ObjectNode ?: return@mapNotNull null
            VulnerabilityData(
                cveid = extractCveId(objectNode),
                datePublished = extractDatePublished(objectNode),
                lessThan = extractVersions(objectNode),
                description = extractDescription(objectNode),
                baseScore = extractBaseScore(objectNode),
            )
        }?.filter { it.datePublished.startsWith(targetDate) }
        val pretty = prettyWriter.writeValueAsString(data)
        println(pretty)
        data
    }

    private fun extractCveId(node: JsonNode): String {
        val cveid = node.at("/cveMetadata/cveId")
        return textOrEmpty(cveid)
    }

    private fun extractDatePublished(node: JsonNode): String {
        val datePublished = node.at("/cveMetadata/datePublished")
        return textOrEmpty(datePublished)
    }

    private fun extractBaseScore(node: JsonNode): String {
        val baseScore = node.at("/containers/cna/metrics").get(0)?.at("/cvssV3_1/baseScore")
        return textOrEmpty(baseScore)
    }

    private fun extractVersions(node: JsonNode): String {
        val versions = node.at("/containers/cna/affected")?.get(0)?.at("/versions")
        val str = versions?.joinToString(separator = "\n") { json ->
            json.toString()
                .replace(Regex("[\"{}]"), "")
                .replace(":", ": ")
                .replace(",", ", ")
        }
        return str ?: ""
    }

    private fun extractDescription(node: JsonNode): String {
        val description = node.at("/containers/cna/descriptions").get(0)?.get("value")
        return textOrEmpty(description)
    }

    private fun textOrEmpty(node: JsonNode?): String {
        return if (node != null && node !is MissingNode) {
            node.textValue()
        } else ""
    }
}
