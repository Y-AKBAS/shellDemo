package com.yakbas.shellDemo.commands

import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.node.MissingNode
import com.fasterxml.jackson.databind.node.ObjectNode
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.runBlocking
import org.jetbrains.kotlinx.dataframe.api.rename
import org.jetbrains.kotlinx.dataframe.api.toDataFrame
import org.jetbrains.kotlinx.dataframe.io.writeExcel
import org.slf4j.LoggerFactory
import org.springframework.shell.command.annotation.Command
import org.springframework.web.client.RestClient
import org.springframework.web.client.toEntity
import org.springframework.web.util.UriComponentsBuilder
import java.time.LocalDate
import java.util.Locale

data class VulnerabilityData(
    val program: String,
    val cveid: String,
    val description: String,
    val datePublished: String,
    val baseScore: String,
    val versions: String,
)

data class CveListV5(
    val cvelistv5: List<JsonNode> = listOf(),
)

private const val baseUrl = "https://cve.circl.lu/api"
private const val vulnerabilityUrl = "$baseUrl/vulnerability/search/{vendor}/{product}"
private val vendorSoftwarePairs = setOf(
    "Node.js" to "Node.js",
    "PostgreSQL" to "PostgreSQL",
    "Adobe" to "Acrobat",
    "NGINX" to "NGINX",
    "MongoDB" to "MongoDB",
    "LibreOffice" to "LibreOffice",
    "Teamviewer" to "Teamviewer",
    "PHP" to "PHP",
    "Docker" to "Docker Desktop",
    "OpenSSL" to "OpenSSL",
    "GitLAB" to "GitLAB",
    "python" to "python",
    "zabbix" to "zabbix",
    "grafana" to "grafana",
    "wazuh" to "wazuh",
    "jetbrains" to "IntelliJ IDEA",
)

@Command
class VulnerabilityChecker(
    private val restClient: RestClient,
    private val objectMapper: ObjectMapper
) {

    private val logger = LoggerFactory.getLogger(VulnerabilityChecker::class.java)
    private val prettyWriter = objectMapper.writerWithDefaultPrettyPrinter()

    @Command(command = ["vul"])
    fun fetchVulnerabilities(
    ) = runBlocking {
        println("Fetching Vulnerabilities...")
        val allData = vendorSoftwarePairs.map {
            fetchVulnerability(it.first, it.second)
        }.awaitAll()
            .filterNotNull()
            .flatten()
        println("Writing into excel...")
        writeToExcel(allData)
    }

    private fun CoroutineScope.fetchVulnerability(vendor: String, product: String) = async {
        println("Fetching Vulnerability for vendor: $vendor product: $product ...")
        val targetDate = LocalDate.now().minusDays(1).toString()
        val url = UriComponentsBuilder.fromUriString(vulnerabilityUrl).apply {
            uriVariables(mapOf("vendor" to vendor, "product" to product))
            queryParam("since", targetDate)
        }.encode().build().toUriString()

        val response = restClient.get().uri(url).retrieve().toEntity<CveListV5>()
        val data = response.body?.cvelistv5?.mapNotNull { node ->
            val objectNode = node.get(1) as? ObjectNode ?: return@mapNotNull null
            VulnerabilityData(
                cveid = extractCveId(objectNode),
                datePublished = extractDatePublished(objectNode),
                program = product.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() },
                versions = extractVersions(objectNode),
                description = extractDescription(objectNode),
                baseScore = extractBaseScore(objectNode),
            )
        }?.filter {
            it.datePublished.startsWith(targetDate)
        }
        println(prettyWriter.writeValueAsString(data))
        data
    }

    private fun extractCveId(node: JsonNode): String {
        val cveid = node.at("/cveMetadata/cveId")
        return textOrEmpty(cveid)
    }

    private fun extractDatePublished(node: JsonNode): String {
        val datePublished = node.at("/cveMetadata/datePublished")
        return textOrEmpty(datePublished).substringBefore("T")
    }

    private fun extractBaseScore(node: JsonNode): String {
        val baseScore = node.at("/containers/cna/metrics").get(0)?.at("/cvssV3_1/baseScore")
        return textOrEmpty(baseScore)
    }

    private fun extractVersions(node: JsonNode): String {
        val versions = node.at("/containers/cna/affected")?.get(0)?.at("/versions")
        val str = versions?.joinToString(separator = "\n\n") { json ->
            json.toString()
                .replace(Regex("[\"{}]"), "")
                .replace(":", ": ")
                .replace(",", ", ")
        }
        return str ?: ""
    }

    private fun extractDescription(node: JsonNode): String {
        val description = node.at("/containers/cna/descriptions").get(0)?.get("value")
        return textOrEmpty(description)
    }

    private fun textOrEmpty(node: JsonNode?): String {
        return if (node != null && node !is MissingNode) {
            node.toString().removeSurrounding("\"")
        } else ""
    }

    private fun writeToExcel(data: List<VulnerabilityData>) {
        val frame = data.toDataFrame()
            .rename(
                "program" to "Programm",
                "cveid" to "CVE ID",
                "description" to "Beschreibung",
                "datePublished" to "Datum",
                "baseScore" to "Base Score",
                "versions" to "Version(en)",
            )
        val date = LocalDate.now().toString()

        frame.writeExcel("/Users/yaak/Documents/personal/shellDemo/${date}_vulnerabilities.xlsx")
    }
}
